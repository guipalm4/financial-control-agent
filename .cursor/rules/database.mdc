---
description: Convenções de banco de dados
globs: ["src/features/**/models.py", "migrations/**"]
---

# Database Conventions — Finance Bot Telegram

## Naming

### Tabelas
- Plural, snake_case: `users`, `cards`, `expenses`, `entries`

### Colunas
- snake_case: `created_at`, `user_id`, `is_active`
- FKs com sufixo `_id`: `user_id`, `card_id`, `category_id`
- Timestamps: `created_at`, `updated_at`, `deleted_at`
- Booleans com prefixo: `is_active`, `is_essential`, `is_default`

### Índices
- Prefixo `idx_`: `idx_expenses_user_date`
- Incluir tabela e colunas no nome

## SQLModel Padrões

### Base Model
```python
from datetime import datetime
from uuid import UUID, uuid4
from sqlmodel import Field, SQLModel

class TimestampMixin(SQLModel):
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class BaseModel(TimestampMixin):
    id: UUID = Field(default_factory=uuid4, primary_key=True)
```

### Soft Delete
```python
class SoftDeleteMixin(SQLModel):
    deleted_at: datetime | None = Field(default=None)
    
    @property
    def is_deleted(self) -> bool:
        return self.deleted_at is not None
```

### Exemplo Completo
```python
class Card(BaseModel, SoftDeleteMixin, table=True):
    __tablename__ = "cards"
    
    user_id: UUID = Field(foreign_key="users.id", index=True)
    name: str = Field(max_length=100)
    last_digits: str = Field(max_length=4)
    closing_day: int = Field(ge=1, le=31)
    due_day: int = Field(ge=1, le=31)
    is_active: bool = Field(default=True)
```

## Queries

### Sempre filtrar soft delete
```python
# ✅ Correto
cards = session.exec(
    select(Card)
    .where(Card.user_id == user_id)
    .where(Card.deleted_at == None)
).all()

# ❌ Errado - inclui deletados
cards = session.exec(select(Card).where(Card.user_id == user_id)).all()
```

### Paginação (offset-based)
```python
def list_expenses(user_id: UUID, page: int = 1, per_page: int = 10):
    offset = (page - 1) * per_page
    return session.exec(
        select(Expense)
        .where(Expense.user_id == user_id)
        .order_by(Expense.purchase_date.desc())
        .offset(offset)
        .limit(per_page)
    ).all()
```

## Migrations (Alembic)

### Criar migration
```bash
alembic revision --autogenerate -m "add_cards_table"
```

### Aplicar migrations
```bash
alembic upgrade head
```

### Rollback
```bash
alembic downgrade -1
```

### Convenções de mensagem
- `add_xxx_table` — Nova tabela
- `add_xxx_column_to_yyy` — Nova coluna
- `create_idx_xxx` — Novo índice
- `drop_xxx` — Remoção

## Constraints

### Check constraints
```python
from sqlalchemy import CheckConstraint

class Card(BaseModel, table=True):
    __table_args__ = (
        CheckConstraint("closing_day >= 1 AND closing_day <= 31"),
        CheckConstraint("due_day >= 1 AND due_day <= 31"),
        CheckConstraint("length(last_digits) = 4"),
    )
```

### Unique constraints
```python
from sqlalchemy import UniqueConstraint

class CategorizationHistory(BaseModel, table=True):
    __table_args__ = (
        UniqueConstraint("user_id", "normalized_description"),
    )
```

## Relacionamentos

### One-to-Many
```python
class User(BaseModel, table=True):
    cards: list["Card"] = Relationship(back_populates="user")

class Card(BaseModel, table=True):
    user_id: UUID = Field(foreign_key="users.id")
    user: User = Relationship(back_populates="cards")
```

### Eager Loading
```python
# Evitar N+1
expenses = session.exec(
    select(Expense)
    .options(selectinload(Expense.category))
    .where(Expense.user_id == user_id)
).all()
```

## PII Handling

### Campos PII
| Tabela | Campo | Tratamento |
|--------|-------|------------|
| users | telegram_id | Não logar |
| users | telegram_username | Não logar |
| cards | last_digits | Mascarar em logs |
| expenses | total_amount | Não logar valor |

### Mascaramento
```python
def mask_card(last_digits: str) -> str:
    return f"****{last_digits}"

def mask_amount(amount: Decimal) -> str:
    return "R$***,**"
```
